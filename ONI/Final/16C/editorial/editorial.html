<!DOCTYPE html>
<html>
  <head>
    <title>Editorial - Problema C</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <table border="0" cellspacing="0" cellpadding="0">
      <tbody><tr>
          <td class="header">
            <a href="http://www.dcc.fc.up.pt/oni/">
              <img src="logo-oni.jpg" height="88" width="180" border="1">
            </a>
          </td>
          <td class="header" valign="middle">
            <h1>&nbsp; Problema C - <font color="black">Harmonia entre Nações</font></h1>
          </td>
        </tr>
    </tbody></table>
    <hr>
    <p class="big">
      <b>Tipo de problema:</b> Teoria de Grafos <br>
      <b>Autor do Problema:</b> João Ramos (Warwick Uni.)<br>
    </p>
    <p><b>O Problema</b><br>
      Dado um grafo direcionado com <b>N</b> vertices e <b>M</b> arestas,
      a tua tarefa é determinar tamanho do maior grupo pacífico, ou
      seja, o tamanho do maior grupo de nós do grafo tal que se A e B
      pertencem ao grupo, então existe um caminho de A para B ou de B
      para A.
    </p>

    <p><b>Restrições:</b><br>
      <table>
        <tbody><tr>
            <td><b>1 &le; N &le; 100 000</b></td>
            <td>&nbsp; &nbsp; &nbsp;</td>
            <td>Números de vertices</td>
          </tr>
          <tr>
            <td><b>1 &le; M &le; 500 000</b></td>
            <td>&nbsp; &nbsp; &nbsp;</td>
            <td>Número de arestas</td>
          </tr>
      </tbody></table>
      <br>
    </p>
    
    <hr>

    <p><b>Visão geral do problema e dos grupos de testes:</b><br>
      Neste problema os limites do tamanho do grafo são iguais em
      todos os grupos de testes, variando apenas no tipo de grafos
      que podem aparecer em cada caso.<br>
      O primeiro grupo tem como objectivo ser mais simples para se
      ficar mais confortavel com o problema e entender o que é pedido.<br>
      Depois o segundo grupo inclui apenas um tipo de grafos muito
      interessante e irá fornecer uma componente muito útil para
      resolver os grupos de teste 3 e 4.<br>
      No terceiro grupo de testes o grafo começa a ficar um pouco
      mais complexo mas apenas o suficiente para que ajuda a ter as
      ideias e observações necessárias para resolver o último grupo
      de testes que inclui qualquer tipo de grafo direcionado.<br>
    </p>

    <hr>
      
    <p><b>Grupo de testes 1 (Se existe uma aresta de A para B então também existe uma aresta de B para A):</b><br>
      A primeira observação a fazer neste grupo de testes é que a
      restrição é equivalente a dizer que o grafo é simples (não
      direcionado).<br>
      Quando o grafo não é direcionado um grupo é pacífico se
      pertence à mesma componente conexa.<br>
      Logo o tamanho do maior grupo pacífico é o tamanho da
      <b>maior componente conexa</b>.<br>
      Para determinar a maior componente conexa apenas precisamos
      de fazer uma pesquisa em profundidade (ou em largura, tanto
      faz).<br>
      <br>
      Excerto do código para resolver esta parte:<br>
      
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%; font-size: 70%">vector <span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> g[MAX_N];
<span style="color: #333399; font-weight: bold">int</span> sz[MAX_N], vis[MAX_N];

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">dfs</span>(<span style="color: #333399; font-weight: bold">int</span> v, <span style="color: #333399; font-weight: bold">int</span> c) {
  <span style="color: #008800; font-weight: bold">if</span> (vis[v]) <span style="color: #008800; font-weight: bold">return</span>;
  vis[v] <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">1</span>, sz[c] <span style="color: #333333">++</span>;
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">auto</span> u <span style="color: #333333">:</span> g[v])
    dfs(u, c);
}

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">solve</span>() {
  <span style="color: #333399; font-weight: bold">int</span> ans <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
  memset(sz, <span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #008800; font-weight: bold">sizeof</span> sz);
  memset(vis, <span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #008800; font-weight: bold">sizeof</span> vis);
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i <span style="color: #333333">++</span>) {
    dfs(i, i);
    ans <span style="color: #333333">=</span> max(ans, sz[i]);
  }
  <span style="color: #008800; font-weight: bold">return</span> ans;
}
</pre></div>
      
      <br>
      Esta seria uma solução <b>O(N + M)</b> que daria os <b>20</b> pontos deste grupo de testes.
    </p>
    
    <hr>    

    <p><b>Grupo de testes 2 (Não existem ciclos no grafo):</b><br>
      Neste grupo de testes o grafo já é direcionado mas tem uma
      propriedade muito interessante: é um grafo dirigido acíclico
      (<b>DAG</b>).<br>
      Num DAG, como é a "estrutura" de um grupo pacífico? Ora se
      uma aresta <b>(u,v)</b> pertence a este grupo, então o grupo
      não pode ter qualquer outra aresta <b>(u,w)</b> pois em tal
      caso não haveria um caminho de <b>v</b> para <b>w</b> nem de
      <b>w</b> para <b>v</b>, e o grupo não seria pacífico.<br>
      <br>
      <img src="sample2.png" style="width: 400px">
      <br>
      Com esta observação podemos concluir que um grupo pacífico
      forma um <b>caminho</b> no grafo.<br>
      Para encontrar o maior caminho num DAG devemos usar programação
      dinâmica: o maior caminho que começa no nó <b>i</b> é o maior
      caminho que começa num dos "sucessores" de <b>i</b> mais 1 (o
      próprio nó <b>i</b>).<br>
      <br>
      Excerto do código para resolver esta parte:<br>

<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%; font-size: 70%">vector <span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> g[MAX_N];
<span style="color: #333399; font-weight: bold">int</span> dp[MAX_N];

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">mx_path</span>(<span style="color: #333399; font-weight: bold">int</span> v) {
  <span style="color: #008800; font-weight: bold">if</span> (dp[v] <span style="color: #333333">==</span> <span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>) {
    dp[v] <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">1</span>;
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">auto</span> u <span style="color: #333333">:</span> g[v])
      dp[v] <span style="color: #333333">=</span> max(dp[v], <span style="color: #0000DD; font-weight: bold">1</span> <span style="color: #333333">+</span> mx_path(u));
  }
  <span style="color: #008800; font-weight: bold">return</span> dp[v];
}

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">solve</span>() {
  <span style="color: #333399; font-weight: bold">int</span> ans <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
  memset(dp, <span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #008800; font-weight: bold">sizeof</span> dp);
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i <span style="color: #333333">++</span>)
    ans <span style="color: #333333">=</span> max(ans, mx_path(i));
  <span style="color: #008800; font-weight: bold">return</span> ans;
}
</pre></div>
      
      <br>
      Esta seria uma solução <b>O(N + M)</b> que daria os <b>30</b> pontos deste grupo de testes.<br>
      <br>
      <b>Nota:</b> a solução para este grupo de testes (com uma ligeira modificação) vai ser útil para
      resolver os grupos de testes que se seguem.
    </p>
    
    <hr>
    
    <p><b>Grupo de testes 3 (Cada habitante confia no máximo num outro habitante):</b><br>
      Neste grupo de testes o grafo temos que o outdegree de cada nó é no máximo 1. Como se pode parecer
      um tal grafo? Vê a figura abaixo com dois exemplos representativos da estrutura deste tipo de grafos:<br>
      <br>
      <img src="sample3.png">
      <br>
      Repara que o que temos são várias "àrvores invertidas" ligadas a um ciclo. No exemplo da esquerda
      esse ciclo é composto apenas pelo nó 6 e no exemplo da direita o ciclo é composto pelos nós 8 a 12.<br>
      É altura então de fazer uma observação importante:<br>
      <b>Se um nó qualquer do ciclo pertence a um grupo pacífico, então esse grupo pode incluir também todos
	os outros nós que fazem parte do mesmo ciclo.</b><br>
      Esta observação permite-nos comprimir o ciclo num só nó. Ao comprimirmos os ciclos num só nó o grafo
      resultante é um DAG e já sabemos como resolver esse caso (apenas precisamos de alterar ligeiramente a
      solução do 2º grupo de testes para ter em conta o número de nós que estão comprimidos em cada nó). Vê
      na figura abaixo como ficaria a compressão do grafo da figura anterior (o número dentro de cada nó
      representa o número de nós comprimidos nele):<br>
      <br>
      <img src="sample3_after.png">
      <br>
      Vamos então agora ver um excerto de código que trata desta compressão e a ligeira alteração a fazer
      na solução anterior, que vamos depois usar para resolver este grupo de testes e o seguinte também.<br>
      <br>
      
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%; font-size: 70%">vector <span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> g[MAX_N];
<span style="color: #333399; font-weight: bold">int</span> p[MAX_N], sz[MAX_N], dp[MAX_N];

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">init</span>() {
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i <span style="color: #333333">++</span>)
    p[i] <span style="color: #333333">=</span> i, sz[i] <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">1</span>;
}

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">contract</span>(<span style="color: #333399; font-weight: bold">int</span> u, <span style="color: #333399; font-weight: bold">int</span> v) {
  <span style="color: #008800; font-weight: bold">if</span> (u <span style="color: #333333">==</span> v) <span style="color: #008800; font-weight: bold">return</span>;
  sz[u] <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>, p[u] <span style="color: #333333">=</span> v, sz[v] <span style="color: #333333">++</span>;
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">auto</span> w <span style="color: #333333">:</span> g[u])
    g[v].push_back(w);
}

<span style="color: #888888">// Slight modification of subtask 2</span>
<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">mx_wpath</span>(<span style="color: #333399; font-weight: bold">int</span> v) {
  <span style="color: #008800; font-weight: bold">if</span> (dp[v] <span style="color: #333333">==</span> <span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>) {
    dp[v] <span style="color: #333333">=</span> sz[v];
    <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">auto</span> u <span style="color: #333333">:</span> g[v])
      <span style="color: #008800; font-weight: bold">if</span> (p[u] <span style="color: #333333">!=</span> v)
	dp[v] <span style="color: #333333">=</span> max(dp[v], sz[v] <span style="color: #333333">+</span> max_wpath(p[u]));
  }
  <span style="color: #008800; font-weight: bold">return</span> dp[v];
}

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">mx_wcc</span>() {
  <span style="color: #333399; font-weight: bold">int</span> ans <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;
  memset(dp, <span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #008800; font-weight: bold">sizeof</span> dp);
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i <span style="color: #333333">++</span>)
    ans <span style="color: #333333">=</span> max(ans, mx_wpath(i));
  <span style="color: #008800; font-weight: bold">return</span> ans;
}
</pre></div>
      
      <br>
      Com isto, apenas precisamos de identificar o ciclo para o poder comprimir. Dado o tipo de
      grafo que pode aparecer aqui, uma possível estratégia é começar em cada nó e ir seguindo o
      caminho até chegar a um nó "sem saída" ou até visitar um nó que já foi visto antes e, neste
      caso, encontrámos um ciclo e podemos comprimi-lo. É importante também ir marcando todos os nós
      já visitados (e em que iteração foram visitados) para garantir que não processamos cada nó mais
      do que uma vez.<br>
      <br>
      Excerto do código para resolver esta parte:<br>
      <br>
      
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%; font-size: 70%">vector <span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> g[MAX_N];
<span style="color: #333399; font-weight: bold">int</span> vis[MAX_N];

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">solve</span>() {
  init();
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i <span style="color: #333333">++</span>)
    <span style="color: #008800; font-weight: bold">if</span> (<span style="color: #333333">!</span>vis[i]) {
      vis[i] <span style="color: #333333">=</span> i;
      <span style="color: #333399; font-weight: bold">int</span> cur <span style="color: #333333">=</span> i;
      <span style="color: #008800; font-weight: bold">while</span> (<span style="color: #333333">!</span>g[cur].empty() <span style="color: #333333">&amp;&amp;</span> <span style="color: #333333">!</span>vis[g[cur][<span style="color: #0000DD; font-weight: bold">0</span>]]) {
	vis[g[cur][<span style="color: #0000DD; font-weight: bold">0</span>]] <span style="color: #333333">=</span> i <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>;
	cur <span style="color: #333333">=</span> g[cur][<span style="color: #0000DD; font-weight: bold">0</span>];
      }
      <span style="color: #008800; font-weight: bold">if</span> (<span style="color: #333333">!</span>g[cur].empty() <span style="color: #333333">&amp;&amp;</span> vis[g[cur][<span style="color: #0000DD; font-weight: bold">0</span>]] <span style="color: #333333">==</span> i <span style="color: #333333">+</span> <span style="color: #0000DD; font-weight: bold">1</span>) {
	<span style="color: #333399; font-weight: bold">int</span> cur2 <span style="color: #333333">=</span> g[cur][<span style="color: #0000DD; font-weight: bold">0</span>];
	<span style="color: #008800; font-weight: bold">while</span> (cur2 <span style="color: #333333">!=</span> cur) {
	  contract(cur2, cur);
	  cur2 <span style="color: #333333">=</span> g[cur2][<span style="color: #0000DD; font-weight: bold">0</span>];
	}
      }
    }
  <span style="color: #008800; font-weight: bold">return</span> max_wcc();
}
</pre></div>
      
      <br>
      Esta seria uma solução <b>O(N + M)</b> que daria os <b>30</b> pontos deste grupo de testes.
    </p>
    
    <hr>
    
    <p><b>Grupo de testes 4:</b><br>
      Chegamos por fim ao último grupo de testes que inclui qualquer tipo de grafo dirigido.<br>
      No grupo de testes anterior usamos uma técnica interessante: comprimir nós de forma a
      obtermos um DAG equivalente (no contexto do nosso problema). Será que podemos fazer algo
      semelhante num grafo qualquer? Como já deves estar a contar, a resposta é sim! Mas como?<br>
      Ora, no caso anterior comprimimos um ciclo porque incluir todos os nós do mesmo é melhor
      do que incluir apenas um, e podemos fazer isto porque incluir todos os outros nós não
      estraga o facto de o grupo ser pacífico. Mas esta propriedade não é exclusiva dos ciclos,
      todas as <b>componentes fortemente conexas</b> têm esta propriedade.<br>
      <br>
      <img src="sample4.png">
      <br>
      Ao comprimirmos todas as componentes fortemente conexas vamos ter um DAG e já sabemos como
      o resolver. Resta-nos então saber como descobrir estas componentes que é um problema clássico
      de grafos e para o qual existem dois algoritmos bastante conhecidos: Kosaraju e Tarjan (vê as
      "ligações interessantes" no fundo desta página). Podes ver no exemplo abaixo a utilização
      do <b>algoritmo de Kosaraju</b> para encontrar estas componentes.<br>
      <br>
      Excerto do código para resolver esta parte:<br>
      <br>
      
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%; font-size: 70%">vector <span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> g[MAX_N], S;
<span style="color: #333399; font-weight: bold">int</span> vis[MAX_N];

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">pre_scc</span>(<span style="color: #333399; font-weight: bold">int</span> v) {
  <span style="color: #008800; font-weight: bold">if</span> (vis[v]) <span style="color: #008800; font-weight: bold">return</span>;
  vis[v] <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">1</span>;
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">auto</span> u <span style="color: #333333">:</span> g[v])
    pre_scc(u);
  S.push_back(v);
}

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">contract_scc</span>(<span style="color: #333399; font-weight: bold">int</span> u, <span style="color: #333399; font-weight: bold">int</span> v) {
  <span style="color: #008800; font-weight: bold">if</span> (vis[u]) <span style="color: #008800; font-weight: bold">return</span>;
  vis[u] <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">1</span>;
  contract(u, v);
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">auto</span> w <span style="color: #333333">:</span> h[u])
    contract_scc(w, v);
}

<span style="color: #333399; font-weight: bold">int</span> <span style="color: #0066BB; font-weight: bold">solve</span>() {
  init();
  memset(vis, <span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #008800; font-weight: bold">sizeof</span> vis);
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> n; i <span style="color: #333333">++</span>)
    pre_scc(i);
  memset(vis, <span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #008800; font-weight: bold">sizeof</span> vis);
  <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> n <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>; i <span style="color: #333333">&gt;=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">--</span>)
    contract_scc(S[i], S[i]);
  <span style="color: #008800; font-weight: bold">return</span> max_wcc();
}
</pre></div>
      
      <br>
      Esta seria uma solução <b>O(N + M)</b> que daria os tão desejados <b>100</b> pontos.
    </p>

    <hr>
    
    <p><b>Ligações interessantes:</b></p>
    <ul> 
      <li>Componentes fortemente conexas na <a href="https://en.wikipedia.org/wiki/Strongly_connected_component">Wikipedia</a>.</li>
      <li>"Competitive Programming 3": Algoritmo de Kosaraju para componentes fortemente conexas.</li>
      <li>"Competitive Programming 3": Algoritmo de Tarjan para componentes fortemente conexas.</li>
    </ul> 
  </body>
</html>
